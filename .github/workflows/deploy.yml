name: Deploy Fullstack App

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  DOCKER_USERNAME: ledjam
  FRONTEND_IMAGE: ledjam/frontend-app
  BACKEND_IMAGE: ledjam/backend-api
  NOTIFICATION_EMAIL: diegomelna14@gmail.com

jobs:
  checkout:
    name: Checkout Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Show repository structure
        run: |
          echo "üìÅ Estructura del repositorio:"
          ls -la

  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: checkout
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Backend image
        uses: docker/build-push-action@v4
        with:
          context: ./Backend
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:latest
            ${{ env.BACKEND_IMAGE }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:latest
          cache-to: type=inline

      - name: Build and push Frontend image
        uses: docker/build-push-action@v4
        with:
          context: ./Frontend
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:latest
            ${{ env.FRONTEND_IMAGE }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:latest
          cache-to: type=inline

  infrastructure:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    needs: build
    outputs:
      instance_ip: ${{ steps.terraform-output.outputs.ip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Configure Oracle Cloud credentials
        run: |
          mkdir -p ~/.oci
          echo "${{ secrets.OCI_PRIVATE_KEY }}" > ~/.oci/private_key.pem
          chmod 600 ~/.oci/private_key.pem

      - name: Create terraform.tfvars
        run: |
          cd Terraform
          cat > terraform.tfvars <<EOF
          tenancy_ocid = "${{ secrets.OCI_TENANCY_OCID }}"
          user_ocid = "${{ secrets.OCI_USER_OCID }}"
          fingerprint = "${{ secrets.OCI_FINGERPRINT }}"
          private_key_path = "$HOME/.oci/private_key.pem"
          region = "${{ secrets.OCI_REGION }}"
          compartment_ocid = "${{ secrets.OCI_COMPARTMENT_OCID }}"
          subnet_id = "${{ secrets.OCI_SUBNET_ID }}"
          availability_domain = "${{ secrets.OCI_AVAILABILITY_DOMAIN }}"
          ubuntu_image_ocid = "${{ secrets.OCI_UBUNTU_IMAGE_OCID }}"
          ssh_public_key = "${{ secrets.SSH_PUBLIC_KEY }}"
          EOF

      - name: Terraform Init
        run: |
          cd Terraform
          terraform init

      - name: Terraform Validate
        run: |
          cd Terraform
          terraform validate

      - name: Terraform Plan
        run: |
          cd Terraform
          terraform plan -out=tfplan

      - name: Terraform Apply
        run: |
          cd Terraform
          terraform apply -auto-approve tfplan

      - name: Get Instance IP
        id: terraform-output
        run: |
          cd Terraform
          INSTANCE_IP=$(terraform output -raw instance_public_ip)
          echo "ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Instance IP: $INSTANCE_IP"

      - name: Wait for instance to be ready
        run: |
          echo "‚è≥ Esperando a que la instancia est√© lista..."
          sleep 60

  setup_docker:
    name: Install Docker on VM
    runs-on: ubuntu-latest
    needs: infrastructure
    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Wait for SSH to be ready
        run: |
          INSTANCE_IP="${{ needs.infrastructure.outputs.instance_ip }}"
          echo "‚è≥ Esperando conexi√≥n SSH en $INSTANCE_IP..."
          
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
              -i ~/.ssh/id_rsa ubuntu@$INSTANCE_IP "echo '‚úÖ SSH conectado'"; then
              echo "‚úì Conexi√≥n SSH establecida!"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚úó Timeout esperando SSH"
              exit 1
            fi
            
            echo "Intento $i/30 - esperando 10 segundos..."
            sleep 10
          done

      - name: Wait for cloud-init and system updates to complete
        run: |
          INSTANCE_IP="${{ needs.infrastructure.outputs.instance_ip }}"
          
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$INSTANCE_IP << 'ENDSSH'
            echo "=== ‚è≥ Esperando que cloud-init termine ==="
            cloud-init status --wait || true
            
            echo "=== ‚è≥ Esperando que apt termine procesos autom√°ticos ==="
            # Esperar hasta 5 minutos para que apt se libere
            timeout=300
            elapsed=0
            
            while [ $elapsed -lt $timeout ]; do
              if ! sudo fuser /var/lib/apt/lists/lock >/dev/null 2>&1 && \
                 ! sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 && \
                 ! sudo fuser /var/lib/dpkg/lock >/dev/null 2>&1; then
                echo "‚úÖ apt est√° disponible"
                break
              fi
              
              echo "‚è≥ apt est√° bloqueado, esperando... ($elapsed/$timeout segundos)"
              sleep 10
              elapsed=$((elapsed + 10))
            done
            
            # Matar procesos de apt si a√∫n est√°n corriendo
            if [ $elapsed -ge $timeout ]; then
              echo "‚ö†Ô∏è Timeout alcanzado, matando procesos de apt..."
              sudo killall apt apt-get || true
              sleep 5
            fi
            
            # Limpiar bloqueos si existen
            sudo rm -f /var/lib/apt/lists/lock
            sudo rm -f /var/lib/dpkg/lock-frontend
            sudo rm -f /var/lib/dpkg/lock
            sudo rm -f /var/cache/apt/archives/lock
            
            # Reconfigurar dpkg por si qued√≥ algo corrupto
            sudo dpkg --configure -a
            
            echo "‚úÖ Sistema listo para instalaci√≥n"
          ENDSSH

      - name: Install Docker and Docker Compose
        run: |
          INSTANCE_IP="${{ needs.infrastructure.outputs.instance_ip }}"
          
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$INSTANCE_IP << 'ENDSSH'
            set -e
            
            echo "=== üîÑ Actualizando sistema ==="
            sudo apt-get update -y
            
            echo "=== üì¶ Instalando dependencias ==="
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release \
              apt-transport-https
            
            echo "=== üîë Agregando Docker GPG key ==="
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
              sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            echo "=== üìã Agregando repositorio de Docker ==="
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
              https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | \
              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            echo "=== üê≥ Instalando Docker ==="
            sudo apt-get update -y
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
              docker-ce \
              docker-ce-cli \
              containerd.io \
              docker-compose-plugin
            
            echo "=== ‚öôÔ∏è Configurando Docker ==="
            sudo systemctl start docker
            sudo systemctl enable docker
            sudo usermod -aG docker ubuntu
            
            echo "=== üì• Instalando Docker Compose standalone ==="
            sudo curl -L \
              "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" \
              -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            
            echo "=== üî• Configurando firewall ==="
            sudo ufw --force enable
            sudo ufw allow 22/tcp
            sudo ufw allow 80/tcp
            sudo ufw allow 443/tcp
            sudo ufw allow 3000/tcp
            sudo ufw allow 8000/tcp
            
            echo "=== üõ°Ô∏è Configurando iptables para Oracle Cloud ==="
            sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 80 -j ACCEPT
            sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 443 -j ACCEPT
            sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 3000 -j ACCEPT
            sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 8000 -j ACCEPT
            
            # Instalar iptables-persistent para guardar reglas
            echo iptables-persistent iptables-persistent/autosave_v4 boolean true | sudo debconf-set-selections
            echo iptables-persistent iptables-persistent/autosave_v6 boolean true | sudo debconf-set-selections
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent
            sudo netfilter-persistent save
            
            echo "=== ‚úÖ Verificando instalaciones ==="
            docker --version
            docker-compose --version
            
            echo "=== üéâ ¬°Instalaci√≥n de Docker completada exitosamente! ==="
          ENDSSH

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [infrastructure, setup_docker]
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.infrastructure.outputs.instance_ip }} >> ~/.ssh/known_hosts

      - name: Copy docker-compose.yml to server
        run: |
          scp -i ~/.ssh/id_rsa docker-compose.yml ubuntu@${{ needs.infrastructure.outputs.instance_ip }}:/home/ubuntu/

      - name: Deploy with Docker Compose
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.infrastructure.outputs.instance_ip }} << 'EOF'
            set -e
            
            echo "=== üîê Logging into Docker Hub ==="
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ env.DOCKER_USERNAME }}" --password-stdin
            
            echo "=== üì• Pulling Docker images ==="
            docker pull ${{ env.BACKEND_IMAGE }}:latest
            docker pull ${{ env.FRONTEND_IMAGE }}:latest
            
            echo "=== üõë Deteniendo contenedores existentes ==="
            docker compose down || true
            
            echo "=== üöÄ Iniciando nuevos contenedores ==="
            docker compose up -d
            
            echo "=== üìä Mostrando estado de contenedores ==="
            docker ps
            
            echo "=== üìã Verificando logs ==="
            sleep 10
            docker compose logs --tail=50
            
            echo "=== ‚úÖ Despliegue completado ==="
          EOF

      - name: Verify Firewall Configuration
        run: |
          ssh -i ~/.ssh/id_rsa ubuntu@${{ needs.infrastructure.outputs.instance_ip }} << 'EOF'
            echo "=== üîç Verificando configuraci√≥n del firewall ==="
            sudo ufw status verbose
            echo ""
            echo "=== üîç Verificando reglas de iptables ==="
            sudo iptables -L INPUT -n --line-numbers | grep -E '(3000|8000)'
          EOF

      - name: Health Check
        run: |
          echo "üîç Verificando estado de la aplicaci√≥n..."
          sleep 15
          
          BACKEND_URL="http://${{ needs.infrastructure.outputs.instance_ip }}:8000/api/health"
          FRONTEND_URL="http://${{ needs.infrastructure.outputs.instance_ip }}:3000"
          
          echo "Verificando Backend: $BACKEND_URL"
          curl -f $BACKEND_URL || echo "‚ö†Ô∏è Backend no responde a√∫n"
          
          echo "Verificando Frontend: $FRONTEND_URL"
          curl -f $FRONTEND_URL || echo "‚ö†Ô∏è Frontend no responde a√∫n"

  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [infrastructure, deploy]
    if: always()
    steps:
      - name: Send Success Email
        if: success()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "‚úÖ Despliegue Exitoso - Pr√°ctica 3.2"
          to: ${{ env.NOTIFICATION_EMAIL }}
          from: GitHub Actions
          body: |
            ‚úÖ El despliegue se complet√≥ exitosamente!
            
            üìã Detalles del Despliegue:
            - Repositorio: ${{ github.repository }}
            - Commit: ${{ github.sha }}
            - Rama: ${{ github.ref_name }}
            - Ejecutado por: ${{ github.actor }}
            
            üåê URLs de Acceso:
            - Frontend: http://${{ needs.infrastructure.outputs.instance_ip }}:3000
            - Backend: http://${{ needs.infrastructure.outputs.instance_ip }}:8000
            - Backend API Info: http://${{ needs.infrastructure.outputs.instance_ip }}:8000/api/info
            
            üñ•Ô∏è IP P√∫blica: ${{ needs.infrastructure.outputs.instance_ip }}
            
            üîó Ver workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Send Failure Email
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "‚ùå Despliegue Fallido - Pr√°ctica 3.2"
          to: ${{ env.NOTIFICATION_EMAIL }}
          from: GitHub Actions
          body: |
            ‚ùå El despliegue ha fallado!
            
            üìã Detalles del Despliegue:
            - Repositorio: ${{ github.repository }}
            - Commit: ${{ github.sha }}
            - Rama: ${{ github.ref_name }}
            - Ejecutado por: ${{ github.actor }}
            
            üñ•Ô∏è IP P√∫blica (si fue provisionada): ${{ needs.infrastructure.outputs.instance_ip }}
            
            üîó Ver logs del error: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            Por favor revisa los logs para m√°s detalles.